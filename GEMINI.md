# 프로젝트 가이드라인

이 문서는 LLM이 프로젝트의 맥락을 정확히 이해하고, 더 효율적이며 프로젝트에 특화된 도움을 제공하도록 돕기 위해 작성되었습니다.

## 프로젝트 개요 및 목표

* 프로젝트 이름: 엘라마켓 (Ellamarket)

* 목표: 총판 정책으로 가격을 외부에 공개할 수 없는 제약이 있는 상황에서, 로그인 후에만 가격을 공개하여 일반 소비자에게 독점적인 가성비와 희소성 높은 상품을 제공하는 프리미엄 소매 스토어를 구축합니다. 이를 통해 사용자는 '남다른 득템의 즐거움'을 경험하고, 서비스는 초대 코드 기반의 성장 루프와 공유하기 기능을 통해 신규 사용자를 자연스럽게 유입시킵니다.

* 주요 기능 (MVP): 이 프로젝트가 제공하는 핵심 기능들을 나열합니다. 각 기능에 해당하는 사용자 스토리 ID를 함께 명시하면 LLM이 특정 기능 개발 시 맥락을 이해하는 데 도움이 됩니다.

    * [US-001] 상품 목록 및 상세 페이지 (가격 비공개 버전): 비회원 방문자는 상품 이미지, 상세 설명, 특징, 후기(부분적)를 볼 수 있지만, 가격은 '로그인 후 확인'으로 표시됩니다.

    * [US-002] 간편 회원가입 및 로그인: 이메일/비밀번호 기반 및 소셜 로그인(구글/카카오)을 통해 사용자가 빠르게 회원으로 전환하고 가격 정보를 확인할 수 있습니다.

    * [US-003] 로그인 후 가격 공개 및 구매 기능: 로그인한 회원에게는 상품의 실제 총판 가격(또는 파격가)을 공개하고, 장바구니, 결제, 주문 내역 조회 등 기본적인 이커머스 구매 기능을 제공합니다.

    * [US-004] 관리자 상품 등록 및 주문 관리 시스템 (CMS): 운영자가 상품 정보(이미지, 가격, 설명), 재고를 업로드/수정하고 주문 내역을 관리할 수 있습니다.

    * [US-005] 기본 검색 및 카테고리/필터: 사용자가 상품명 검색, 카테고리 분류, 신상품/인기 상품 등의 필터를 사용하여 원하는 상품을 쉽게 찾을 수 있습니다.

    * [US-006] AI 기반 '숨겨진 보석' 상품 추천 (초기 버전): 로그인한 사용자에게 과거 조회/구매 이력을 기반으로 '엘라마켓이 선정한 숨겨진 보석' 등 AI 큐레이션 상품을 보여줍니다.

    * [US-007] 로그인 후 상품 공유하기 및 추천인 수익 지급: 로그인한 회원은 상품 상세 페이지에서 '공유하기' 버튼을 통해 고유한 링크를 생성하고, 이 링크로 접속한 비회원은 로그인 없이 해당 상품의 가격을 즉시 확인할 수 있습니다. 이 링크를 통해 구매가 발생하면, 공유한 회원에게 구매 금액의 5%가 적립됩니다.

* 프로젝트 깃헙 레포지토리: `https://github.com/0disoft/ellamarket`

## 기술 스택 및 환경

* 프론트엔드: SvelteKit

    * 스타일링: Tailwind CSS + shadcn-svelte

    * UI/UX 특징 (선택 사항): 깔끔하면서도 프리미엄하고 신비로운 분위기, 독점적인 '득템' 경험을 시각적으로 강조. 다크 모드 버튼 지원, 글꼴 사이즈 변경(총 9단계, 기본 5단계) 기능 지원.

* 백엔드: ElysiaJS

* 런타임: Bun

* 데이터베이스/BaaS: Supabase

* 배포 환경:

    * 프론트엔드 배포: Cloudflare Pages

    * 백엔드 배포: Render

* 의존성 관리: Bun을 패키지 매니저로 사용하며, 정기적인 의존성 업데이트 및 취약점 검토를 수행합니다.

* 프로젝트 구조: 모노레포 (Monorepo)

    * 설명: 프론트엔드(SvelteKit)와 백엔드(ElysiaJS) 코드를 단일 GitHub 저장소 내에서 관리합니다. 이를 통해 공통 코드 공유, 버전 관리 용이성, 통합된 개발 워크플로우의 이점을 활용합니다.

* 지역화 (l10n, 선택 사항):

    * 다국어 페이지 지원 여부: 지원함 (MVP 이후 고려)

    * 기본 언어: 한국어 (접속 국가 언어로 자동 선택 지원은 MVP 이후 고려)

    * 번역 파일 관리 방식: 수동 준비 (LLM 이용 포함)

* 개발 환경:

    * OS: Windows 11

    * IDE: VS Code

    * 터미널: Git Bash

    * 권장 확장 프로그램: VS Code with Svelte, Tailwind CSS IntelliSense, Prettier, ESLint

## 코딩 규칙 및 스타일

* 코드 포맷팅: Prettier를 따르며, 코드 리뷰 전에 자동으로 포맷팅을 적용합니다.

* 변수/함수명: 명확하고 의미를 쉽게 유추할 수 있는 이름을 사용합니다. (예: `getData` 대신 `fetchProductDetails`, `calculateDiscount` 대신 `applyMemberDiscount`)

* 주석: 코드의 '어떻게(How)'가 아닌 '왜(Why)'를 설명하는 주석을 작성합니다. 복잡한 비즈니스 로직, 설계 결정, 기술적 절충안 등을 설명할 때만 사용합니다. 코드만 봐도 알 수 있는 명백한 사실은 굳이 주석으로 달아서 노이즈를 만들 필요 없습니다.

* 테스트: 모든 핵심 비즈니스 로직(예: 가격 계산, 인증/인가 로직, 결제 처리)에 대해 단위 테스트를 작성합니다. (특히 정확성이 중요한 계산 로직 등)

* 코드 라인 길이: 한 줄의 최대 길이는 80자 (띄어쓰기 포함)를 지킵니다.

* 함수 길이: 함수의 최대 길이는 50라인 (주석 및 줄바꿈 포함)을 지킵니다.

* 들여쓰기: 2칸 공백을 사용합니다.

* 커밋 메시지: Gitmoji 형식(`:emoji: type(scope): subject`)을 사용한 영어 코멘트를 작성합니다. (예: `:sparkles: feat: implement user registration with social login`, `:bug: fix: resolve cart item quantity update issue`)

## 설계 원칙 및 제약 사항

* 모듈성: 코드를 작고 응집도 높은 모듈(컴포넌트, 서비스, 유틸리티 함수)로 분리하여 재사용성과 유지보수성을 높입니다.

* 가독성: 다른 개발자가 코드를 쉽게 이해할 수 있도록 작성합니다.

* 성능: 특히 상품 조회, 로그인, 결제 등 핵심 사용자 흐름에서는 성능을 최우선으로 고려합니다. Bun 런타임과 SvelteKit의 SSR 활용으로 빠른 로딩 속도를 확보합니다.

* 보안: 사용자 데이터 보호, 인증/인가(Supabase RLS 활용), 입력 유효성 검사 등 보안을 항상 염두에 둡니다. 민감한 가격 정보는 백엔드에서 안전하게 처리하고 클라이언트에게는 로그인 시에만 노출합니다. 단, '공유하기' 링크를 통해 접근하는 경우에 한해 예외적으로 가격을 공개할 수 있도록 보안 정책을 유연하게 설계합니다.

* 데이터 정확성: 제공되는 상품 정보(특히 가격, 재고)는 최대한의 정확성을 보장해야 합니다. 부동 소수점 오류 방지를 위한 정밀한 숫자 연산 라이브러리 사용을 권장합니다.

* 에러 처리: 모든 잠재적인 에러 상황에 대해 견고하고 명확한 에러 처리 로직을 구현합니다. 서버 측 폼 액션(`+page.server.ts`) 내에서 `fail` 함수를 사용하여 적절한 HTTP 상태 코드와 함께 데이터를 반환함으로써, 사용자에게 특정하고 사용자 정의된 오류 메시지를 표시하고 개발자에게는 구체적인 오류 정보를 전달합니다.

* 접근성 (A11y): 웹 애플리케이션 개발 시 웹 접근성 표준을 준수하여 모든 사용자가 쉽게 접근하고 이용할 수 있도록 처음부터 강력한 접근성을 보장합니다.

* Single Source of Truth: 서비스 이름, API 엔드포인트, 주요 설정 값 등은 코드 곳곳에 하드코딩하지 않습니다. 모든 설정은 별도의 설정 파일이나 상수 모듈에 모아서, 딱 한 군데만 수정하면 전체에 적용되도록 만듭니다.

## AI 지식 베이스 및 문서화

LLM의 학습 데이터 한계(Knowledge Cutoff)를 극복하고, 프로젝트의 기술적 맥락과 최신 정보를 정확하게 파악하기 위해 이 중앙화된 지식 베이스를 관리합니다. 코드를 분석하거나 생성할 때, 항상 이 내부 지식 베이스의 문서를 가장 먼저 확인하십시오.

* **위치**: LLM과 관련된 모든 문서는 `/.gemini/` 폴더 아래에 중앙화하여 관리합니다.

### 1. 프레임워크 최신 정보 (`/.gemini/framework-updates/`)

* **목적**: 주요 프레임워크의 최신 패치 노트와 핵심 변경 사항을 요약하여 LLM의 지식 격차를 해소합니다.
* **내용**: `[프레임워크명]-[년도]-q[분기].md` 형식으로 파일이 정리되어 있습니다.
* **LLM 활용 가이드**: 특정 라이브러리나 프레임워크 관련 작업을 수행할 때, 이 디렉토리의 문서를 참조하여 가장 현대적이고 관용적인 코드를 생성하십시오.

### 2. 아키텍처 결정 기록 (`/.gemini/adr/`)

* **목적**: "왜(Why)" 특정 기술 스택이나 설계 패턴을 선택했는지 등, 프로젝트의 중요한 기술적 결정에 대한 이유와 배경을 기록합니다.
* **내용**: `001-monorepo-structure-decision.md` 와 같이 번호가 매겨진 마크다운 파일로 관리됩니다.
* **LLM 활용 가이드**: 새 ADR 작성 시 `_template.md` 파일을 복사하여 형식을 유지하십시오. 코드 제안 시에는 이 문서에 기록된 제약 조건과 역사적 맥락을 반드시 고려하십시오.

### 3. API 명세 (`/.gemini/api/`)

* **목적**: 주요 API 엔드포인트의 요청/응답 형식, 파라미터, 인증 요구사항, 반환 에러 코드 등을 명확하게 정의합니다.
* **내용**: `authentication.md`, `products.md` 와 같이 기능별로 파일이 분리되어 있습니다.
* **LLM 활용 가이드**: 새 API 문서 작성 시 `_template.md` 파일을 복사하여 구조를 유지하십시오. API 호출 또는 신규 엔드포인트 구현 시, 이 명세를 기준으로 정확한 코드를 생성하십시오.

### 4. 데이터 흐름 (`/.gemini/data-flow/`)

* **목적**: 사용자의 특정 행동이 시스템 전체(프론트엔드, 백엔드, 데이터베이스)에서 어떻게 처리되는지 그 과정을 기록합니다.
* **내용**: `checkout-process.md` 와 같이 핵심 사용자 시나리오별로 파일이 정리되어 있습니다.
* **LLM 활용 가이드**: 새 흐름도 작성 시 `_template.md` 파일을 참고하십시오. 풀스택 기능 개발 및 디버깅 시, 이 흐름도를 바탕으로 시스템 간 상호작용을 파악하고 코드를 작성하십시오.

### 5. 테스트 전략 (`/.gemini/testing/`)

* **목적**: 프로젝트의 테스트 철학, 종류별 테스트 작성법, 모킹(mocking) 가이드라인 등을 정의하여 코드 품질과 일관성을 확보합니다.
* **내용**: 테스트 전략, 종류별 가이드, 모킹 방법 등이 기술됩니다.
* **LLM 활용 가이드**: 새 테스트 가이드 작성 시 `_template.md` 파일을 참고하십시오. 새로운 기능을 개발할 때, 이 가이드라인에 따라 적절한 테스트 코드를 함께 생성하십시오.

### 6. 배포 가이드 (`/.gemini/deployment/`)

* **목적**: CI/CD 파이프라인의 흐름, 필수 환경 변수, 빌드 및 배포 과정을 문서화합니다.
* **내용**: 환경별 구성, 필수 환경 변수 목록, 배포 과정 등이 기술됩니다.
* **LLM 활용 가이드**: 새 배포 문서 작성 시 `_template.md` 파일을 참고하십시오. 배포 관련 스크립트나 설정 파일 수정 시, 이 문서를 참조하여 운영 환경에 영향을 주지 않도록 하십시오.

### 7. 공통 코드 패턴 (`/.gemini/patterns/`)

* **목적**: 프로젝트 전반에서 반복적으로 사용되는 고유한 코드 패턴이나 아키텍처 "레시피"를 기록하여 재사용성과 일관성을 높입니다.
* **내용**: 커스텀 훅, 상태 관리 로직 등 프로젝트 고유의 구현 패턴들이 정리되어 있습니다.
* **LLM 활용 가이드**: 새 패턴 문서 작성 시 `_template.md` 파일을 참고하십시오. 새로운 기능을 개발할 때, 먼저 이 디렉토리에서 재사용 가능한 패턴이 있는지 확인하고 적용하십시오.

### 8. UI/UX 가이드라인 (`/.gemini/ui-ux-guidelines/`)

* **목적**: 디자인 시스템, 컴포넌트 사용 원칙, 색상 팔레트, 타이포그래피 등 프론트엔드 개발 시 지켜야 할 규칙을 제공합니다.
* **내용**: 컴포넌트별 사용법, 디자인 토큰, 접근성 규칙 등이 기술됩니다.
* **LLM 활용 가이드**: 새 가이드라인 작성 시 `_template.md` 파일을 참고하십시오. 새로운 UI를 생성하거나 수정할 때, 이 가이드라인을 준수하여 디자인 통일성을 유지하십시오.

## 기타 AI 지침

* LLM 출력 검증: LLM이 제안한 코드는 문법적으로는 완벽할지라도, 미묘한 논리적 결함이나 성능 문제를 포함할 수 있습니다. AI의 제안을 맹목적으로 수락하지 않고, 항상 개발자 본인이 최종적인 설계 결정과 엄격한 검증의 책임을 가집니다. 특히 컴파일러 오류 수정 시 LLM의 변경 사항이 코드의 의도된 논리를 어떻게 바꾸는지 충분히 이해해야 합니다.

* LLM의 한계 인지:

    * LLM은 훈련 데이터의 최신성에 제한되어, 더 이상 관용적이거나 유효하지 않은 오래된 라이브러리 버전이나 언어 패턴을 사용할 수 있습니다. 항상 최신 문서와 모범 사례를 확인합니다.

    * 선택한 언어나 프레임워크의 관용적인 스타일에 맞지 않는 코드를 생성할 수 있습니다 (예: Sveltekit의 `stores` 대신 전역 변수 사용, ElysiaJS에서 비효율적인 라우팅). 이를 수정하여 코드 품질을 유지합니다.

* 코드를 생성할 때 "가능한 가장 빠른 조회 시간에 최적화된"과 같이 성능을 우선시하도록 명시적으로 지시합니다.

* LLM을 초안 생성 도구로 활용한 후, 로직을 비판적으로 검토하고 더 구체적인 프롬프트로 유도하여 코드를 개선합니다.

* 전체 앱을 한번에 작성하기보다는 잘게 분할된 작고, 잘 정의되고, 격리된 부분을 구현하는 것이 효과적입니다. 인간 개발자의 주된 역할은 깔끔한 아키텍처를 설계한 다음, LLM을 사용하여 그 아키텍처의 작고, 잘 정의되고, 격리된 부분을 채우는 것입니다. LLM은 인간 개발자의 아키텍처나 설계 제안에 대해 잠재적인 문제점(예: 복잡성, 비효율성)을 식별하고, 데이터 기반의 대안을 제시하여 설계를 개선하는 데 조언해야 합니다.

## 추가 조언 (Additional Guidance)

이 섹션은 프로젝트의 특정 요구사항이나 개발자가 LLM에게 추가적으로 기대하는 역할을 명시하는 공간입니다.

* 명확한 유효성 검사 규칙을 정의하고 사용자 정의된 설명적인 오류 메시지를 제공합니다. 사용자가 입력할 때 실시간 유효성 검사를 구현하여 즉각적인 피드백을 제공합니다. 유효하지 않은 필드를 강조 표시하거나 피드백 컴포넌트(툴팁, 입력 필드 옆 오류 메시지)와 같은 시각적 단서를 사용하여 사용자를 안내합니다.

* 소프트웨어에서 발생하는 예외나 잘못된 값은 종종 더 깊은 곳에 있는 설계 결함의 '증상'일 뿐입니다. 예를 들어, `null` 예외를 막기 위해 `null` 체크를 추가하는 것은 증상을 억제하는 임시방편일 뿐, 왜 `null` 값이 애초에 그곳까지 전달되었는지 근본 원인을 파고들어 해결해야 합니다. 근본 원인을 해결하는 것은 단순히 버그 하나를 고치는 것을 넘어, 시스템 전체의 안정성과 예측 가능성을 높이는 핵심적인 활동입니다.

* 코드의 가독성과 유지보수성을 확보하기 위해 모든 리터럴 값은 가급적 상수로 정의합니다.

* 코드 구조화를 고려하여 모듈별로 파일을 분리합니다. (하나의 파일에 모든 코드 작성 지양)

* Playwright의 내장된 자동 대기 메커니즘과 웹 우선 어설션의 자동 재시도 기능을 전적으로 신뢰하여 `waitForTimeout`과 같은 임의의 지연을 피하세요. 이는 테스트 불안정성을 줄이고, 테스트 실행 속도를 향상시키며, 테스트 코드를 UI 상호 작용의 세부 사항보다는 비즈니스 로직에 더 집중하도록 만들 수 있습니다.

* `+layout.svelte` 파일을 사용하여 중첩된 경로 전체에 걸쳐 유지되는 공유 UI 요소(예: 헤더, 사이드바, 내비게이션 바)를 정의하여 코드 중복을 방지합니다.

---
